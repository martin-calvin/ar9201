/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <stdio.h>
#include <fcntl.h>
#include <pthread.h>

#include "ar_dsp_rpc.h"

#include "ar_ion.h"
#include "ar_alg.h"

#define AR_GET_ION_MEMORY(VA, PA, SIZE) \
do{ \
	VA = (unsigned char *)ar_ion_malloc(SIZE); \
	if(!VA) \
	{ \
		printf("%s %d: Malloc memory failed, exit!\r\n", __FUNCTION__, __LINE__); \
		goto _free_and_exit; \
	} \
	PA = (unsigned char *)ar_ion_virt_to_phy(VA); \
	if(!PA) \
	{ \
		printf("%s %d: Virt to phy failed, exit!\r\n", __FUNCTION__, __LINE__); \
		goto _free_and_exit; \
	} \
	memset(VA, 0, SIZE); \
}while(0)

#define AR_RELEASE_ION_MEMORY(VA) ar_ion_free(VA)

#define AR_DSP_ALG_MAX_NN_PER_DSP   16
#define AR_DSP_ALG_MAX_INPUT_NUM     4
#define AR_DSP_ALG_MAX_OUTPUT_NUM     16

#define AR_MAX_NETWORKS           (4 * AR_DSP_ALG_MAX_NN_PER_DSP)
#define MAX_OUTPUT_PDATA_SIZE    1048576
#define AR_ION_DSP_HEAP_ID       27

struct AR_WEIGHT_FILE_st
{
	char name[128];
	unsigned long va;
	unsigned long pa;
	unsigned long file_len;
	unsigned long offset;
	int ready;
	pthread_mutex_t lock;
};

struct AR_ION_MEM_st
{
	unsigned long pa;
	unsigned long va;
	unsigned long len;
};

struct AR_DSP_CONFIG_DATA_st
{
	int dsp_configured;
	struct AR_ION_MEM_st input[AR_DSP_ALG_MAX_INPUT_NUM];
	pthread_mutex_t lock;
};

static struct AR_DSP_CONFIG_DATA_st g_dsp_cfg_data[4] = {0};

static struct AR_WEIGHT_FILE_st g_weight_file_st[AR_MAX_NETWORKS] = {0};

//get every input's max len
static int ar_get_max_input_len(AR_DSP_CFG_RPC_st *argp, int input_id)
{
	int max_len = 0, len = 0;
	int i = 0;

	for(i = 0; i < AR_DSP_ALG_MAX_NN_PER_DSP; i++)
	{
		if(argp->dsp_cfg_st.cnn_cfg[i].network_id == 0)
		{
			continue;
		}

		len = argp->dsp_cfg_st.cnn_cfg[i].input_buf_len[input_id];
		if(len > max_len)
		{
			max_len = len;
		}

	}

	return max_len;
}
static int ar_get_max_pdata_len(AR_DSP_CFG_RPC_st *argp)
{
	int max_len = 0, len = 0;
	int i = 0;

	for(i = 0; i < AR_DSP_ALG_MAX_NN_PER_DSP; i++)
	{
		if(argp->dsp_cfg_st.cnn_cfg[i].network_id == 0)
		{
			continue;
		}

		len = argp->dsp_cfg_st.cnn_cfg[i].len_of_buffer_for_pdata;
		if(len > max_len)
		{
			max_len = len;
		}

	}

	return max_len;

}

static int ar_prepare_weight_file(AR_DSP_CFG_RPC_st *argp)
{
	int i, j;

	for(i = 0; i < AR_DSP_ALG_MAX_NN_PER_DSP; i++)
	{
		if(argp->dsp_cfg_st.cnn_cfg[i].network_id == 0)
		{
			continue;
		}

		for(j = 0; j < AR_MAX_NETWORKS; j++)
		{
			if(strcmp(argp->dsp_cfg_st.cnn_cfg[i].weight_file_path, g_weight_file_st[j].name) == 0
				&& argp->dsp_cfg_st.cnn_cfg[i].file_len == g_weight_file_st[j].file_len
				&& g_weight_file_st[j].ready)
			{
				argp->dsp_cfg_st.cnn_cfg[i].load_addr = g_weight_file_st[j].pa;
				break;
			}
		}

		if(j >= AR_MAX_NETWORKS)
		{
			printf("Network %d has no weight file!\r\n", i);
			return -1;
		}
	}

	//we don't consider NULL dsp_cfg
	return 0;
}

int ar_alg_rpc_svr_init()
{
	int i = 0;

	ar_ion_init(AR_ION_DSP_HEAP_ID);

	//put some init here
	memset(g_dsp_cfg_data, 0, sizeof(g_dsp_cfg_data));

	for(i = 0; i < 4; i++)
	{
		pthread_mutex_init(&g_dsp_cfg_data[i].lock, NULL);
	}

	memset(g_weight_file_st, 0, sizeof(g_weight_file_st));

	for(i = 0; i < AR_MAX_NETWORKS; i++)
	{
		pthread_mutex_init(&g_weight_file_st[i].lock, NULL);
	}

	return 0;
}

int ar_alg_rpc_svr_deinit()
{
	int i = 0;

	//put some init here
	for(i = 0; i < 4; i++)
	{
		pthread_mutex_destroy(&g_dsp_cfg_data[i].lock);
	}

	for(i = 0; i < AR_MAX_NETWORKS; i++)
	{
		pthread_mutex_destroy(&g_weight_file_st[i].lock);
	}

	ar_ion_uninit();

	return 0;
}

int *
ar_alg_cfg_dsp_1_svc(AR_DSP_CFG_RPC_st *argp, struct svc_req *rqstp)
{
	static int  result;

	/*
	 * insert server code here
	 */
	int dsp_id;
	int i = 0;
	unsigned long input_va[AR_DSP_ALG_MAX_INPUT_NUM] = {0};
	unsigned long input_pa[AR_DSP_ALG_MAX_INPUT_NUM] = {0};
	unsigned long input_len[AR_DSP_ALG_MAX_INPUT_NUM] = {0};
	unsigned long output_pdata_len = 0;
	unsigned long output_pdata_pa = 0;
	unsigned long output_pdata_va = 0;
	unsigned long ext_mem_addr_va = 0;
	unsigned long ext_mem_addr_pa = 0;
	unsigned long sram_addr_va = 0;
	unsigned long sram_addr_pa = 0;

	if(!argp)
	{
		printf("%s,%d: invalid params!\r\n", __FUNCTION__, __LINE__);
		result = -1;
		return &result;
	}

	dsp_id = argp->dsp_id;

	pthread_mutex_lock(&g_dsp_cfg_data[dsp_id].lock);
	if(g_dsp_cfg_data[dsp_id].dsp_configured)
	{
		result = -2;
		pthread_mutex_unlock(&g_dsp_cfg_data[dsp_id].lock);
		return &result;
	}
	pthread_mutex_unlock(&g_dsp_cfg_data[dsp_id].lock);

	//get ion for input buf
	for(i = 0; i < AR_DSP_ALG_MAX_INPUT_NUM; i++)
	{
		input_len[i] = ar_get_max_input_len(argp, i);
		if(input_len[i] <= 0)
		{
			continue;
		}

		printf("[DSP%d]Malloc input buf len %d\r\n", dsp_id, input_len[i]);
		AR_GET_ION_MEMORY(input_va[i], input_pa[i], input_len[i]);
		printf("[DSP%d]Input va %x pa %x\r\n", dsp_id, input_va[i], input_pa[i]);
	}

	//get ion for output pdata
	output_pdata_len = ar_get_max_pdata_len(argp);
	printf("[DSP%d]Malloc output pdata buf len %d\r\n", dsp_id, output_pdata_len);
	AR_GET_ION_MEMORY(output_pdata_va, output_pdata_pa, output_pdata_len);
	printf("[DSP%d]Output_pdata va %x pa %x\r\n", dsp_id, output_pdata_va, output_pdata_pa);

	//Malloc ext memory for cdnn lib
	printf("[DSP%d]Malloc ext mem len %d\r\n", dsp_id, argp->dsp_cfg_st.cdnn_ext_mem_size);
	AR_GET_ION_MEMORY(ext_mem_addr_va, ext_mem_addr_pa, argp->dsp_cfg_st.cdnn_ext_mem_size);
	printf("[DSP%d]Ext va %x pa %x\r\n", dsp_id, ext_mem_addr_va, ext_mem_addr_pa);

	//check if sram is configured
	if(!argp->dsp_cfg_st.cdnn_sram_heap_start && argp->dsp_cfg_st.cdnn_sram_heap_size)
	{
		AR_GET_ION_MEMORY(sram_addr_va, sram_addr_pa, argp->dsp_cfg_st.cdnn_sram_heap_size);
		argp->dsp_cfg_st.cdnn_sram_heap_start = (unsigned long)sram_addr_pa;
	}

	printf("[DSP%d]Svr: get file name: %s\r\n", dsp_id, argp->dsp_cfg_st.cnn_cfg[0].weight_file_path);

	//Check if weight file is recved from host and set weight file addr
	if(ar_prepare_weight_file(argp) < 0)
	{
		printf("[DSP%d]Prepare weight file error!\r\n", dsp_id);
		result = -3;
		goto _free_and_exit;
	}

	for(i = 0; i < AR_DSP_ALG_MAX_NN_PER_DSP; i++)
	{
		if(argp->dsp_cfg_st.cnn_cfg[i].network_id == 0)
		{
			continue;
		}

		argp->dsp_cfg_st.cnn_cfg[i].input_buf[0] = input_pa[0];
		argp->dsp_cfg_st.cnn_cfg[i].input_buf[1] = input_pa[1];
		argp->dsp_cfg_st.cnn_cfg[i].input_buf[2] = input_pa[2];
		argp->dsp_cfg_st.cnn_cfg[i].input_buf[3] = input_pa[3];

		argp->dsp_cfg_st.cnn_cfg[i].input_buf_len[0] = input_len[0];
		argp->dsp_cfg_st.cnn_cfg[i].input_buf_len[1] = input_len[1];
		argp->dsp_cfg_st.cnn_cfg[i].input_buf_len[2] = input_len[2];
		argp->dsp_cfg_st.cnn_cfg[i].input_buf_len[3] = input_len[3];

		argp->dsp_cfg_st.cnn_cfg[i].len_of_buffer_for_pdata = output_pdata_len;
		argp->dsp_cfg_st.cnn_cfg[i].buffer_pa_for_pdata = output_pdata_pa;
		argp->dsp_cfg_st.cnn_cfg[i].buffer_va_for_pdata = output_pdata_va;
	}
	argp->dsp_cfg_st.cdnn_ext_mem_addr = ext_mem_addr_pa;

	//Call dsp api
	result = ar_alg_cfg_dsp(dsp_id, (char *)&argp->dsp_cfg_st, sizeof(argp->dsp_cfg_st));
	if(result == 0)
	{
		pthread_mutex_lock(&g_dsp_cfg_data[dsp_id].lock);

		g_dsp_cfg_data[dsp_id].dsp_configured = 1;
		g_dsp_cfg_data[dsp_id].input[0].pa = input_pa[0];
		g_dsp_cfg_data[dsp_id].input[1].pa = input_pa[1];
		g_dsp_cfg_data[dsp_id].input[2].pa = input_pa[2];
		g_dsp_cfg_data[dsp_id].input[3].pa = input_pa[3];

		g_dsp_cfg_data[dsp_id].input[0].va = input_va[0];
		g_dsp_cfg_data[dsp_id].input[1].va = input_va[1];
		g_dsp_cfg_data[dsp_id].input[2].va = input_va[2];
		g_dsp_cfg_data[dsp_id].input[3].va = input_va[3];

		g_dsp_cfg_data[dsp_id].input[0].len = input_len[0];
		g_dsp_cfg_data[dsp_id].input[1].len = input_len[1];
		g_dsp_cfg_data[dsp_id].input[2].len = input_len[2];
		g_dsp_cfg_data[dsp_id].input[3].len = input_len[3];

		pthread_mutex_unlock(&g_dsp_cfg_data[dsp_id].lock);

		result = 0;
		return &result;
	}
	else
	{
		printf("Config DSP %d failed!\r\n");
		result = -4;
	}

_free_and_exit:
	//free all resources
	for(i = 0; i < AR_DSP_ALG_MAX_INPUT_NUM; i++)
	{
		if(input_va[i])
		{
			AR_RELEASE_ION_MEMORY(input_va[i]);
		}
	}

	if(output_pdata_va)
	{
		AR_RELEASE_ION_MEMORY(output_pdata_va);
	}

	if(ext_mem_addr_va)
	{
		AR_RELEASE_ION_MEMORY(ext_mem_addr_va);
	}

	if(sram_addr_va)
	{
		AR_RELEASE_ION_MEMORY(sram_addr_va);
	}

	return &result;
}

AR_DSP_ALG_RPC_OUT_st *
ar_do_algrithom_1_svc(AR_DSP_ALG_RPC_IN_st *argp, struct svc_req *rqstp)
{
	static AR_DSP_ALG_RPC_OUT_st  result;
	int i = 0;
	int ret = 0;

	/*
	 * insert server code here
	 */

	AR_DSP_ALG_st dsp_alg = {0};

	//copy params and get input img data
	dsp_alg.dsp_id = argp->dsp_id;
	dsp_alg.alg_type = argp->alg_type;
	memcpy(&dsp_alg.cv_ops, &argp->cv_ops, sizeof(argp->cv_ops));
	for(i = 0; i < AR_DSP_ALG_MAX_INPUT_NUM; i++)
	{
		if(argp->input[i].size && g_dsp_cfg_data[argp->dsp_id].input[i].va)
		{
			dsp_alg.input[i].width = argp->input[i].width;
			dsp_alg.input[i].height = argp->input[i].height;
			dsp_alg.input[i].channel = argp->input[i].channel;
			dsp_alg.input[i].format = argp->input[i].format;
			dsp_alg.input[i].y_stride = argp->input[i].y_stride;
			dsp_alg.input[i].u_stride = argp->input[i].u_stride;
			dsp_alg.input[i].v_stride = argp->input[i].v_stride;
			dsp_alg.input[i].y_addr = argp->input[i].y_addr;
			dsp_alg.input[i].u_addr = argp->input[i].u_addr;
			dsp_alg.input[i].v_addr = argp->input[i].v_addr;
			dsp_alg.input[i].size = argp->input[i].size;

			memcpy(g_dsp_cfg_data[argp->dsp_id].input[i].va, argp->input[i].rgbbuff, argp->input[i].size);
			dsp_alg.input[i].rgbbuff = g_dsp_cfg_data[argp->dsp_id].input[i].pa;
		}

	}

	printf("Svr: get dspid %d alg type %d\r\n", dsp_alg.dsp_id, dsp_alg.alg_type);

	//call dsp api
	ret = ar_do_algrithom(&dsp_alg);
	if(ret < 0)
	{
		result.exit_code = ret;
	}
	else
	{
		//copy output results
		result.output.buffer_num = dsp_alg.output.buffer_num;
		for(i = 0; i < result.output.buffer_num; i++)
		{
			result.output.output_buffer[i].width = dsp_alg.output.output_buffer[i].width;
			result.output.output_buffer[i].height = dsp_alg.output.output_buffer[i].height;
			result.output.output_buffer[i].nchannels = dsp_alg.output.output_buffer[i].nchannels;
			result.output.output_buffer[i].nInputs = dsp_alg.output.output_buffer[i].nInputs;
			result.output.output_buffer[i].buffer_size = dsp_alg.output.output_buffer[i].buffer_size;

			strcpy(result.output.output_buffer[i].buffer_name, dsp_alg.output.output_buffer[i].buffer_name);
			memcpy(result.output.output_buffer[i].pdata, dsp_alg.output.output_buffer[i].pdata,
				result.output.output_buffer[i].buffer_size > MAX_OUTPUT_PDATA_SIZE ? MAX_OUTPUT_PDATA_SIZE : result.output.output_buffer[i].buffer_size);
		}

		//copy statistics
		memcpy(&result.statistics, &dsp_alg.statistics, sizeof(dsp_alg.statistics));

	}

	result.dsp_id = argp->dsp_id;
	result.alg_type = argp->alg_type;

	return &result;
}

AR_DSP_ALG_RPC_OUT_st *
ar_do_algrithom_with_timeout_1_svc(AR_DSP_ALG_TO_RPC_IN_st *argp, struct svc_req *rqstp)
{
	static AR_DSP_ALG_RPC_OUT_st  result;
	int i = 0;
	int ret = 0;

	/*
	 * insert server code here
	 */

	AR_DSP_ALG_st dsp_alg = {0};

	//copy params and get input img data
	dsp_alg.dsp_id = argp->ar_alg_rpc_st.dsp_id;
	dsp_alg.alg_type = argp->ar_alg_rpc_st.alg_type;
	memcpy(&dsp_alg.cv_ops, &argp->ar_alg_rpc_st.cv_ops, sizeof(argp->ar_alg_rpc_st.cv_ops));
	for(i = 0; i < AR_DSP_ALG_MAX_INPUT_NUM; i++)
	{
		if(argp->ar_alg_rpc_st.input[i].size && g_dsp_cfg_data[argp->ar_alg_rpc_st.dsp_id].input[i].va)
		{
			dsp_alg.input[i].width = argp->ar_alg_rpc_st.input[i].width;
			dsp_alg.input[i].height = argp->ar_alg_rpc_st.input[i].height;
			dsp_alg.input[i].channel = argp->ar_alg_rpc_st.input[i].channel;
			dsp_alg.input[i].format = argp->ar_alg_rpc_st.input[i].format;
			dsp_alg.input[i].y_stride = argp->ar_alg_rpc_st.input[i].y_stride;
			dsp_alg.input[i].u_stride = argp->ar_alg_rpc_st.input[i].u_stride;
			dsp_alg.input[i].v_stride = argp->ar_alg_rpc_st.input[i].v_stride;
			dsp_alg.input[i].y_addr = argp->ar_alg_rpc_st.input[i].y_addr;
			dsp_alg.input[i].u_addr = argp->ar_alg_rpc_st.input[i].u_addr;
			dsp_alg.input[i].v_addr = argp->ar_alg_rpc_st.input[i].v_addr;
			dsp_alg.input[i].size = argp->ar_alg_rpc_st.input[i].size;

			memcpy(g_dsp_cfg_data[argp->ar_alg_rpc_st.dsp_id].input[i].va, argp->ar_alg_rpc_st.input[i].rgbbuff, argp->ar_alg_rpc_st.input[i].size);
			dsp_alg.input[i].rgbbuff = g_dsp_cfg_data[argp->ar_alg_rpc_st.dsp_id].input[i].pa;
		}

	}

	//call dsp api
	ret = ar_do_algrithom_with_timeout(&dsp_alg, argp->timeout);
	if(ret < 0)
	{
		result.exit_code = ret;
	}
	else
	{
		//copy output results
		result.output.buffer_num = dsp_alg.output.buffer_num;
		for(i = 0; i < result.output.buffer_num; i++)
		{
			result.output.output_buffer[i].width = dsp_alg.output.output_buffer[i].width;
			result.output.output_buffer[i].height = dsp_alg.output.output_buffer[i].height;
			result.output.output_buffer[i].nchannels = dsp_alg.output.output_buffer[i].nchannels;
			result.output.output_buffer[i].nInputs = dsp_alg.output.output_buffer[i].nInputs;
			result.output.output_buffer[i].buffer_size = dsp_alg.output.output_buffer[i].buffer_size;
			strcpy(result.output.output_buffer[i].buffer_name, dsp_alg.output.output_buffer[i].buffer_name);
			memcpy(result.output.output_buffer[i].pdata, dsp_alg.output.output_buffer[i].pdata,
				result.output.output_buffer[i].buffer_size > MAX_OUTPUT_PDATA_SIZE ? MAX_OUTPUT_PDATA_SIZE : result.output.output_buffer[i].buffer_size);
		}

	}

	result.dsp_id = argp->ar_alg_rpc_st.dsp_id;
	result.alg_type = argp->ar_alg_rpc_st.alg_type;

	return &result;
}

int *
ar_send_file_1_svc(AR_FILE_CHUNK_st *argp, struct svc_req *rqstp)
{
	static int  result;
	int i = 0;
	int find = 0;
	unsigned long pa, va;
	/*
	 * insert server code here
	 */

	//printf("Svr: file %s, total %d, bytes %d\r\n", argp->name, argp->total_len, argp->chunk_bytes);
	if(argp->chunk_bytes == 0 || argp->total_len == 0 || argp->total_len < argp->chunk_bytes)
	{
		result = -1;
		return &result;
	}

	for(i = 0; i < AR_MAX_NETWORKS; i++)
	{
		pthread_mutex_lock(&g_weight_file_st[i].lock);
		if(strcmp(g_weight_file_st[i].name, argp->name) == 0)
		{
			memcpy((char *)(g_weight_file_st[i].va + g_weight_file_st[i].offset), argp->data, argp->chunk_bytes);
			g_weight_file_st[i].offset += argp->chunk_bytes;
			if(g_weight_file_st[i].offset == g_weight_file_st[i].file_len)
			{
				printf("Svr: get file done!\r\n");
				g_weight_file_st[i].ready = 1;
			}

			pthread_mutex_unlock(&g_weight_file_st[i].lock);
			result = argp->chunk_bytes;
			return &result;
		}
		pthread_mutex_unlock(&g_weight_file_st[i].lock);
	}

	//Get an empty struct and save this file to it.
	AR_GET_ION_MEMORY(va, pa, argp->total_len);

	for(i = 0; i < AR_MAX_NETWORKS; i++)
	{
		pthread_mutex_lock(&g_weight_file_st[i].lock);
		if(g_weight_file_st[i].name[0] == 0 && g_weight_file_st[i].va == 0)
		{
			strcpy(g_weight_file_st[i].name, argp->name);
			g_weight_file_st[i].pa = pa;
			g_weight_file_st[i].va = va;
			g_weight_file_st[i].file_len = argp->total_len;
			g_weight_file_st[i].ready = 0;
			g_weight_file_st[i].offset = 0;

			memcpy(va, argp->data, argp->chunk_bytes);
			g_weight_file_st[i].offset += argp->chunk_bytes;
			if(g_weight_file_st[i].offset == g_weight_file_st[i].file_len)
			{
				printf("Svr: get file done!\r\n");
				g_weight_file_st[i].ready = 1;
			}

			pthread_mutex_unlock(&g_weight_file_st[i].lock);
			result = argp->chunk_bytes;
			return &result;
		}
		pthread_mutex_unlock(&g_weight_file_st[i].lock);
	}

_free_and_exit:
	result = -1;
	return &result;
}


